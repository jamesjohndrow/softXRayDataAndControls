# importing generic python modules
import numpy as np
import psana
import abc

def defaultDetectors(hutch):
    if hutch.lower()=='amo':
        dets = amoDetectors()
    elif hutch.lower()=='sxr':
        dets = sxrDetectors()
    elif hutch.lower()=='xpp':
        dets = xppDetectors()
    elif hutch.lower()=='xcs':
        dets = xcsDetectors()
    elif hutch.lower()=='mfx':
        dets = mfxDetectors()
    elif hutch.lower()=='cxi':
        dets = cxiDetectors()
    elif hutch.lower()=='mec':
        dets = mecDetectors()
    else:
        dets = []
    detsInRun= [ det for det in dets if det.inRun() ]
    print 'found %d detectors '%len(detsInRun)
    return detsInRun

def amoDetectors():
    return []

def sxrDetectors():
    return []

def xppDetectors(beamCodes=[[162],[91]]):
    dets=[]
    dets.append(lightStatus(codes=beamCodes))
    dets.append(ipmDetector('NH2-SB1-IPM-01','ipm1'))
    dets.append(ipmDetector('NH2-SB1-IPM-02','ipm1c'))
    dets.append(ipmDetector('XppMon_Pim0','lombpm'))
    dets.append(ipmDetector('XppMon_Pim1','lomdiode'))
    dets.append(ipmDetector('XppSb2_Ipm','ipm2'))
    dets.append(ipmDetector('XppSb3_Ipm','ipm3'))
    dets.append(ipmDetector('XppSb3_Pim','diode2'))
    dets.append(ipmDetector('XppSb4_Pim','diode2'))
    dets.append(ipmDetector('XppEnds_Ipm0','diodeU'))
    dets.append(epicsDetector(PVlist=['att_T', 'att_T3rd', 'slit_s1_hw', 'slit_s1_vw', 'slit_s2_hw', 'slit_s2_vw', 'slit_s3_hw', 'slit_s3_vw', 'slit_s4_hw', 'slit_s4_vw', 'lxt_vitara', 'lxt', 'lxt_ttc', 'lxe', 'ccm_E', 'lom_E', 'lom_EC', 'gon_v', 'gon_h', 'gon_r', 'gon_x', 'gon_y', 'gon_z', 'gon_roll', 'gon_pitch', 'gon_kappa_eta', 'gon_kappa_kappa', 'gon_kappa_phi', 'gon_phi', 'gon_kappa_samx','gon_kappa_samy', 'gon_kappa_samz', 'robot_x', 'robot_y', 'robot_z', 'robot_rx', 'robot_ry', 'robot_rz', 'robot_azi', 'robot_ele', 'robot_rad', 'las_comp_wp', 'las_opa_wp']))
    dets.append(encoderDetector('usbencoder','enc'))
    dets.append(controlDetector())
    dets.append(aiDetector('XPP-AIN-01','ai'))
    dets.append(ttDetector(baseName='XPP:TIMETOOL:'))
    dets.append(bmmonDetector('HX2-BEAMMON-01','ipm_hx2'))
    return dets

def xcsDetectors():
    dets.append(lightStatus(codes=beamCodes))
    dets.append(controlDetector())
    dets.append(ipmDetector('XCS-IPM-02','ipm2'))
    dets.append(ipmDetector('XCS-IPM-03','ipm3'))
    dets.append(ipmDetector('XCS-IPM-05','ipm5'))
    dets.append(ipmDetector('XCS-DIO-03','dio3'))
    dets.append(ipmDetector('XCS-DIO-05','dio5'))
    dets.append(ipmDetector('XCS-IPM-mono','diodeMono'))
    dets.append(ipmDetector('XCS-IPM-gon','diodeGon'))
    dets.append(ipmDetector('XCS-IPM-lam','diodeLadm'))
    #dets.append(ipmDetector('XcsUsrIpm01','diodeU'))
    dets.append(bmmonDetector('HX2-BEAMMON-01','ipm_hx2'))
    dets.append(aiDetector('XCS-AIN-01','ai'))
    dets.append(epicsDetector(PVlist=['att_transmission', 'att_transmission_3rd_h', 'ccm_E', 'lom_E', 'DIFF_phis', 'DIFF_th', 'DIFF_tth', 'DIFF_xs', 'DIFF_ys', 'DIFF_zs', 'DIFF_x', 'DIFF_y', 'DIFF_chis','DIFF_dety','ladm_theta','LAM_Z','LAM_X1','LAM_X2','LAM_Y1','LAM_Y2','LAM_DET_Y','LAM_DET_X']))

    return []

def mfxDetectors():
    return []

def cxiDetectors():
    return []

def mecDetectors():
    return []


def detData(detList, evt):
    data={}
    for det in detList:
        data[det.name] = det.data(evt)
    return data

def setParameter(detList, Params, detName='tt'):
    for det in detList:
        if det.name==detName:
            det.setPars(Params)
    
#
# classes for default detector types
#
class defaultDetector(object):
    __metaclass__ = abc.ABCMeta
    def __init__(self, detname, name):
        self.name=name
        self.detname=detname
        self.det=psana.Detector(detname)
    def inRun(self):
        dNames=[]
        for dn in psana.DetNames():
            for dnn in dn:
                if dnn!='':
                    dNames.append(dnn)
        if self.detname in dNames:
            return True
        return False
    @abc.abstractmethod
    def data(self,evt):
        """method that should return a dict of values from event"""
        

class lightStatus(defaultDetector):
    def __init__(self, detname='evr0', codes=[[162],[]]):
        defaultDetector.__init__(self, detname, 'lightStatus')
        self.xrayCodes = codes[0]
        self.laserCodes = codes[1]

    def data(self,evt):
        xfel_status, laser_status = (1,1) # default if no EVR code matches
        dl={}
        evtCodes = self.det.eventCodes(evt)
        for xOff in self.xrayCodes:
            if xOff in evtCodes:
                xfel_status = 0
        for lOff in self.laserCodes:
            if lOff in evtCodes:
                laser_status = 0
        dl['xray']=xfel_status
        dl['laser']=laser_status
        return dl
        
class ipmDetector(defaultDetector):
    def __init__(self, detname, name=None, savePos=False):
        if name is None:
            self.name = detname
        else:
            self.name = name
        defaultDetector.__init__(self, detname, name)
        self.savePos = savePos
    def data(self, evt):
        dl={}
        dl['sum']=self.det.sum(evt)
        dl['channels']=self.det.channel(evt)
        if self.savePos:
            dl['xpos']=self.det.xpos(evt)
            dl['ypos']=self.det.ypos(evt)
        return dl

class bmmonDetector(defaultDetector):
    def __init__(self, detname, name=None, savePos=False):
        if name is None:
            self.name = detname
        else:
            self.name = name
        defaultDetector.__init__(self, detname, name)
        self.savePos = savePos
    def data(self, evt):
        dl={}
        data = self.det.get(evt)
        dl['sum']=data.TotalIntensity()
        dl['channels']=data.peakA()
        if self.savePos:
            dl['xpos']=data.X_Position()
            dl['ypos']=data.Y_Position()
        return dl

class epicsDetector(defaultDetector):
    def __init__(self, name='epics', PVlist=[]):
        self.name = name
        self.detname='epics'
        self.PVlist = PVlist
        self.pvs=[]
        for pv in PVlist:
            try:
                self.pvs.append(psana.Detector(pv))
            except:
                print 'could not find EPICS PV %s in data'%pv
    def inRun(self):
        if len(self.pvs)>0:
            return True
        return False

    def data(self,evt):
        dl={}
        for pvname,pv in zip(self.PVlist,self.pvs):
            dl[pvname]=pv()
        return dl

class encoderDetector(defaultDetector):
    def __init__(self, detname, name=None):
        if name is None:
            self.name = detname
        else:
            self.name = name
        defaultDetector.__init__(self, detname, name)
    def data(self, evt):
        dl={}
        for desc,value in zip(self.det.descriptions(), self.det.values(evt)):
            if desc!='':
                dl[desc]=value
        return dl

class controlDetector(defaultDetector):
    def __init__(self, name='scan'):
        defaultDetector.__init__(self, 'ControlData', 'scan')
        self.stepPV = psana.Detector('scan_current_step')
    def data(self, evt):
        dl={}
        for icpv,cpv in enumerate(self.det().pvControls()):
            dl['var%d'%icpv]=cpv.value()
            dl[cpv.name()]=cpv.value()
            dl['varStep']=self.stepPV()
        return dl

class aiDetector(defaultDetector):
    def __init__(self, detname, name=None):
        if name is None:
            self.name = detname
        else:
            self.name = name
        defaultDetector.__init__(self, detname, name)
        self.aioInfo = [[ i for i in range(0,16)], [ 'ch%02d'%i for i in range(0,16)], [ 1. for i in range(0,16)], [ 0. for i in range(0,16)]]

    def setPars(self, AIOPars):
        if len(AIOPars)<2:
            print 'need 2/3 lists: channel#, user-friendly names & conversion factors (optional)'
            return
        self.aioInfo[0] = AIOPars[0]
        self.aioInfo[1] = AIOPars[1]
        if len(AIOPars)==3:
            self.aioInfo[2] = AIOPars[2]
            if len(AIOPars)==4:
                self.aioInfo[3] = AIOPars[3]
            else:
                self.aioInfo[3] = [0. for entry in AIOPars[0]]
        else:
            self.aioInfo[2] = [1. for entry in AIOPars[0]]

    def data(self, evt):
        dl={}
        for ichn,chName,chnScale,chnOffset in zip(self.aioInfo[0], self.aioInfo[1], self.aioInfo[2], self.aioInfo[3]):
            dl[chName]=self.det.get(evt).channelVoltages()[ichn]*chnScale+chnOffset
        return dl

class ttDetector(defaultDetector):
    def __init__(self, name='tt', baseName='TTSPEC:'):
        self.name = name
        self.detname='epics'
        self.ttNames = ['FLTPOS','FLTPOS_PS','AMPL','FLTPOSFWHM','REFAMPL','AMPLNXT']
        self.PVlist = [ baseName+pvname for pvname in self.ttNames ]
        self.pvs=[]
        for pv in self.PVlist:
            try:
                self.pvs.append(psana.Detector(pv))
            except:
                print 'could not find timetool EPICS PV %s in data'%pv
        self.ttCalib=None
    def inRun(self):
        if len(self.pvs)>0:
            return True
        return False
    def setPars(self, calibPars):
      if calibPars != None:
        self.ttCalib = calibPars

    def data(self,evt):
        dl={}
        for ttname,pvname,pv in zip(self.ttNames,self.PVlist,self.pvs):
            dl[ttname]=pv()
        ttOrg = dl[self.ttNames[1]]
        if self.ttCalib is None:
            dl['ttCorr']=ttOrg
        else:
            dl['ttCorr']=self.ttCalib[0] + self.ttCalib[1]*ttOrg
            if len(self.ttCalib)>2:
                dl['ttCorr']+=ttOrg*ttOrg*self.ttCalib[2]
        return dl
